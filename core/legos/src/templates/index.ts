/**
 * Template System
 * 
 * Documentation generation and template management for lego assemblies.
 * Creates documentation, READMEs, and other artifacts from composed contexts.
 */

export interface DocumentationTemplate {
  name: string;
  type: 'readme' | 'documentation' | 'configuration' | 'test';
  template: string;
  context_requirements: string[];
}

export interface DocumentationResult {
  success: boolean;
  output?: string;
  errors: string[];
  template_used: string;
}

/**
 * Generates documentation from assembled contexts
 */
export async function generateDocumentation(
  template: string,
  contexts: any[],
  options: { format?: string; includeMetadata?: boolean } = {}
): Promise<DocumentationResult> {
  const { format = 'markdown', includeMetadata = true } = options;
  
  const result: DocumentationResult = {
    success: false,
    errors: [],
    template_used: template
  };
  
  try {
    const docTemplate = await loadDocumentationTemplate(template);
    
    // Validate context requirements
    const validation = validateContextRequirements(docTemplate, contexts);
    if (!validation.valid) {
      result.errors = validation.errors;
      return result;
    }
    
    // Generate documentation
    result.output = await renderDocumentation(docTemplate, contexts, { format, includeMetadata });
    result.success = true;
    
  } catch (error) {
    result.errors.push(`Documentation generation failed: ${error.message}`);
  }
  
  return result;
}

async function loadDocumentationTemplate(templateName: string): Promise<DocumentationTemplate> {
  const templates: Record<string, DocumentationTemplate> = {
    'agent-readme': {
      name: 'agent-readme',
      type: 'readme',
      template: `# {{agent.id}}

**{{agent.description}}**

## 🎭 Agent Profile

- **Archetype**: {{agent.persona.archetype}}
- **Voice**: {{agent.persona.voice}}
{{#if agent.persona.cognitive_bias}}
- **Cognitive Bias**: {{agent.persona.cognitive_bias}}
{{/if}}

## 🧠 Thinking Patterns

{{#each agent.toolkit.thinking_patterns}}
- {{this}}
{{/each}}

{{#if agent.toolkit.agent_tools}}
## 🛠️ Available Tools

{{#each agent.toolkit.agent_tools}}
- {{this}}
{{/each}}
{{/if}}

## 📋 Usage

\`\`\`yaml
# Load this agent
agent: {{agent.id}}
description: "{{agent.description}}"
\`\`\`

---
*Generated by @lev-os/legos*`,
      context_requirements: ['agent']
    },
    'workflow-documentation': {
      name: 'workflow-documentation',
      type: 'documentation',
      template: `# {{workflow.id}} Workflow

**Goal**: {{workflow.goal}}

## 📋 Workflow Overview

{{workflow.description}}

{{#if workflow.recommendations}}
## 👥 Recommended Participants

{{#each workflow.recommendations.participants}}
- **{{role}}**: {{agent_id}} ({{requirement}})
{{/each}}

{{#if workflow.recommendations.patterns}}
## 🧠 Suggested Patterns

{{#each workflow.recommendations.patterns}}
- {{this}}
{{/each}}
{{/if}}
{{/if}}

{{#if workflow.steps}}
## 📝 Execution Steps

{{#each workflow.steps}}
### Step {{@index}}: {{description}}

**Recommendation**: {{recommendation.prompt}}
{{#if recommendation.agent}}
**Suggested Agent**: {{recommendation.agent}}
{{/if}}

{{#if validation}}
**Validation Rules**:
{{#each validation}}
- {{this}}
{{/each}}
{{/if}}

{{/each}}
{{/if}}

---
*Generated by @lev-os/legos*`,
      context_requirements: ['workflow']
    }
  };
  
  const template = templates[templateName];
  if (!template) {
    throw new Error(`Documentation template not found: ${templateName}`);
  }
  
  return template;
}

function validateContextRequirements(
  template: DocumentationTemplate,
  contexts: any[]
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  const contextTypes = contexts.map(c => c.type);
  
  for (const requiredType of template.context_requirements) {
    if (!contextTypes.includes(requiredType)) {
      errors.push(`Template ${template.name} requires context type: ${requiredType}`);
    }
  }
  
  return { valid: errors.length === 0, errors };
}

async function renderDocumentation(
  template: DocumentationTemplate,
  contexts: any[],
  options: { format: string; includeMetadata: boolean }
): Promise<string> {
  // Create template data object
  const templateData: Record<string, any> = {};
  
  // Map contexts by type for easy access in templates
  for (const context of contexts) {
    templateData[context.type] = context;
  }
  
  // Add metadata if requested
  if (options.includeMetadata) {
    templateData.metadata = {
      generated_at: new Date().toISOString(),
      template_used: template.name,
      context_count: contexts.length,
      context_types: [...new Set(contexts.map(c => c.type))]
    };
  }
  
  // Simple template rendering (would use Handlebars in practice)
  let output = template.template;
  
  // Replace variables
  output = output.replace(/\{\{(\w+(?:\.\w+)*)\}\}/g, (match, path) => {
    const value = getNestedValue(templateData, path);
    return value !== undefined ? String(value) : match;
  });
  
  // Handle conditionals
  output = handleConditionals(output, templateData);
  
  // Handle loops
  output = handleLoops(output, templateData);
  
  return output;
}

function getNestedValue(obj: any, path: string): any {
  return path.split('.').reduce((current, key) => current?.[key], obj);
}

function handleConditionals(template: string, data: any): string {
  return template.replace(/\{\{#if (\w+(?:\.\w+)*)\}\}([\s\S]*?)\{\{\/if\}\}/g, (match, path, content) => {
    const value = getNestedValue(data, path);
    return value ? content : '';
  });
}

function handleLoops(template: string, data: any): string {
  return template.replace(/\{\{#each (\w+(?:\.\w+)*)\}\}([\s\S]*?)\{\{\/each\}\}/g, (match, path, content) => {
    const array = getNestedValue(data, path);
    if (!Array.isArray(array)) return '';
    
    return array.map((item, index) => 
      content
        .replace(/\{\{this\}\}/g, String(item))
        .replace(/\{\{@index\}\}/g, String(index))
    ).join('\n');
  });
}