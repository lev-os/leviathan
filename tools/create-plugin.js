#!/usr/bin/env node
/**
 * @kingly/plugin Generator
 * Creates new Kingly plugins with proper structure and integration
 */

import fs from 'fs-extra'
import path from 'path'
import { execSync } from 'child_process'
import readline from 'readline'

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})

const PLUGIN_TYPES = {
  core: 'Core plugin with essential @kingly/cmd integration',
  utility: 'Utility plugin for helper tools and convenience functions', 
  workflow: 'Workflow plugin for complex multi-step processes'
}

const FEATURES = {
  git: 'Git worktree and repository management',
  claude: 'Claude Code spawning and AI coordination',
  parallel: 'Parallel processing and multi-stream development',
  logs: 'Log aggregation and streaming',
  monitor: 'Process monitoring and status tracking'
}

async function prompt(question) {
  return new Promise((resolve) => {
    rl.question(question, resolve)
  })
}

function generatePackageJson(pluginName, pluginType, features) {
  const dependencies = {
    '@kingly/cmd': 'workspace:*'
  }
  
  if (features.includes('git')) {
    dependencies['simple-git'] = '^3.0.0'
  }
  
  if (features.includes('claude')) {
    dependencies['execa'] = '^8.0.0'
  }
  
  return {
    name: `@kingly/${pluginName}`,
    version: '1.0.0',
    description: `Kingly ${pluginType} plugin`,
    type: 'module',
    main: 'src/index.js',
    scripts: {
      build: 'echo "No build needed"',
      test: 'node --test tests/*.test.js',
      dev: 'node --watch src/index.js'
    },
    dependencies,
    devDependencies: {
      '@types/node': '^20.0.0'
    },
    keywords: [
      'kingly',
      'plugin',
      pluginType,
      ...features
    ],
    author: 'Kingly Team',
    license: 'MIT'
  }
}function generatePluginYaml(pluginName, pluginType, features) {
  const capabilities = ['process_management']
  
  if (features.includes('git')) capabilities.push('git_worktree')
  if (features.includes('claude')) capabilities.push('claude_spawning')
  if (features.includes('parallel')) capabilities.push('parallel_processing')
  if (features.includes('logs')) capabilities.push('log_streaming')
  if (features.includes('monitor')) capabilities.push('status_monitoring')
  
  return `# ${pluginName} Plugin Configuration
plugin:
  name: ${pluginName}
  version: 1.0.0
  type: ${pluginType}_plugin
  description: "Generated ${pluginType} plugin for ${pluginName}"
  
capabilities:${capabilities.map(cap => `\n  - ${cap}`).join('')}

commands:
  ${pluginName}_start:
    syntax: "kingly ${pluginName} start [options]"
    description: "Start ${pluginName} operation"
    whisper:
      strategies:
        - "Initialize ${pluginName} with process tracking"
        - "Setup background monitoring if requested"
      llm_guidance: "Use @kingly/cmd process management for execution"
      
  ${pluginName}_status:
    syntax: "kingly ${pluginName} status"
    description: "Check ${pluginName} status"
    whisper:
      strategies:
        - "Query process status and resource usage"
        - "Report current operational state"
      llm_guidance: "Use process registry for status information"

dependencies:
  core_modules:
    - "@kingly/cmd/process-manager"
    - "@kingly/cmd/job-integration"${features.includes('git') ? '\n    - "@kingly/cmd/worktree-manager"' : ''}${features.includes('logs') ? '\n    - "@kingly/cmd/log-aggregator"' : ''}
    
  external_tools:${features.includes('git') ? '\n    - git' : ''}${features.includes('claude') ? '\n    - claude' : ''}
`
}

function generateIndexJs(pluginName, pluginType, features) {
  const imports = ['processManager', 'jobIntegration']
  if (features.includes('git')) imports.push('worktreeManager')
  if (features.includes('logs')) imports.push('logAggregator')
  if (features.includes('claude')) imports.push('claudeSpawner')
  
  return `/**
 * @kingly/${pluginName} - ${pluginType} plugin
 * Generated by @kingly/plugin generator
 */

import { ${imports.join(', ')} } from '@kingly/cmd'
import { loadConfig } from './config.js'

export class ${pluginName.charAt(0).toUpperCase() + pluginName.slice(1)}Plugin {
  constructor() {
    this.config = loadConfig()
    this.processManager = processManager
    this.jobIntegration = jobIntegration${features.includes('git') ? '\n    this.worktreeManager = worktreeManager' : ''}${features.includes('logs') ? '\n    this.logAggregator = logAggregator' : ''}${features.includes('claude') ? '\n    this.claudeSpawner = claudeSpawner' : ''}
  }
  
  async start(options = {}) {
    console.log(\`Starting \${this.config.plugin.name} plugin...\`)
    
    // Create job in ~/mvp system
    const job = await this.jobIntegration.createJob({
      name: \`\${this.config.plugin.name}-start\`,
      command: 'echo "Plugin started"',
      options: { monitor: true, ...options }
    })
    
    // Use process manager for execution
    const process = await this.processManager.spawn('echo', ['Plugin started'], {
      background: options.background || false,
      monitor: true
    })
    
    // Report success
    await this.jobIntegration.reportCompletion(job.id, { 
      success: true, 
      pid: process.pid 
    })
    
    return { job, process }
  }
  
  async status() {
    console.log(\`Checking \${this.config.plugin.name} status...\`)
    
    // Get all processes for this plugin
    const processes = await this.processManager.getProcesses({
      filter: \`\${this.config.plugin.name}-*\`
    })
    
    return {
      plugin: this.config.plugin.name,
      processes: processes.length,
      status: processes.length > 0 ? 'active' : 'inactive'
    }
  }
}

export default ${pluginName.charAt(0).toUpperCase() + pluginName.slice(1)}Plugin
`
}function generateConfigJs() {
  return `/**
 * Plugin configuration loader
 */

import fs from 'fs-extra'
import path from 'path'
import yaml from 'js-yaml'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

export function loadConfig() {
  const configPath = path.join(__dirname, '../config/plugin.yaml')
  
  if (!fs.existsSync(configPath)) {
    throw new Error(\`Plugin configuration not found: \${configPath}\`)
  }
  
  const configContent = fs.readFileSync(configPath, 'utf8')
  return yaml.load(configContent)
}

export function validateConfig(config) {
  if (!config.plugin?.name) {
    throw new Error('Plugin configuration must include plugin.name')
  }
  
  if (!config.plugin?.type) {
    throw new Error('Plugin configuration must include plugin.type')
  }
  
  return true
}
`
}

function generateTestFiles(pluginName) {
  const commandsTest = `/**
 * Tests for ${pluginName} plugin commands
 */

import { test } from 'node:test'
import assert from 'node:assert'
import ${pluginName.charAt(0).toUpperCase() + pluginName.slice(1)}Plugin from '../src/index.js'

test('${pluginName} plugin can be instantiated', async () => {
  const plugin = new ${pluginName.charAt(0).toUpperCase() + pluginName.slice(1)}Plugin()
  assert.ok(plugin)
  assert.ok(plugin.config)
})

test('${pluginName} plugin has required methods', async () => {
  const plugin = new ${pluginName.charAt(0).toUpperCase() + pluginName.slice(1)}Plugin()
  assert.ok(typeof plugin.start === 'function')
  assert.ok(typeof plugin.status === 'function')
})
`

  const integrationTest = `/**
 * Integration tests for ${pluginName} plugin
 */

import { test } from 'node:test'
import assert from 'node:assert'
import ${pluginName.charAt(0).toUpperCase() + pluginName.slice(1)}Plugin from '../src/index.js'

test('${pluginName} plugin integrates with @kingly/cmd', async () => {
  const plugin = new ${pluginName.charAt(0).toUpperCase() + pluginName.slice(1)}Plugin()
  
  // Test process manager integration
  assert.ok(plugin.processManager)
  assert.ok(plugin.jobIntegration)
})

test('${pluginName} plugin status returns valid format', async () => {
  const plugin = new ${pluginName.charAt(0).toUpperCase() + pluginName.slice(1)}Plugin()
  const status = await plugin.status()
  
  assert.ok(status.plugin)
  assert.ok(typeof status.processes === 'number')
  assert.ok(['active', 'inactive'].includes(status.status))
})
`

  return { commandsTest, integrationTest }
}

async function createPlugin() {
  console.log('üöÄ Kingly Plugin Generator\\n')
  
  // Get plugin details
  const pluginName = await prompt('Plugin name (kebab-case): ')
  if (!pluginName || !/^[a-z][a-z0-9-]*$/.test(pluginName)) {
    console.error('‚ùå Invalid plugin name. Use kebab-case (e.g., my-plugin)')
    process.exit(1)
  }
  
  console.log('\\nAvailable plugin types:')
  Object.entries(PLUGIN_TYPES).forEach(([type, desc]) => {
    console.log(\`  \${type}: \${desc}\`)
  })
  
  const pluginType = await prompt('\\nPlugin type (core/utility/workflow): ')
  if (!PLUGIN_TYPES[pluginType]) {
    console.error('‚ùå Invalid plugin type')
    process.exit(1)
  }
  
  console.log('\\nAvailable features:')
  Object.entries(FEATURES).forEach(([feature, desc]) => {
    console.log(\`  \${feature}: \${desc}\`)
  })
  
  const featuresInput = await prompt('\\nFeatures (comma-separated, optional): ')
  const features = featuresInput 
    ? featuresInput.split(',').map(f => f.trim()).filter(f => FEATURES[f])
    : []
  
  rl.close()
  
  // Create plugin directory
  const pluginDir = path.join(process.cwd(), 'packages', pluginName)
  
  if (fs.existsSync(pluginDir)) {
    console.error(\`‚ùå Plugin directory already exists: \${pluginDir}\`)
    process.exit(1)
  }
  
  console.log(\`\\nüìÅ Creating plugin at \${pluginDir}\\n\`)
  
  // Create directory structure
  await fs.ensureDir(path.join(pluginDir, 'src'))
  await fs.ensureDir(path.join(pluginDir, 'config'))
  await fs.ensureDir(path.join(pluginDir, 'tests'))
  
  // Generate files
  const packageJson = generatePackageJson(pluginName, pluginType, features)
  const pluginYaml = generatePluginYaml(pluginName, pluginType, features)
  const indexJs = generateIndexJs(pluginName, pluginType, features)
  const configJs = generateConfigJs()
  const tests = generateTestFiles(pluginName)
  
  // Write files
  await fs.writeFile(
    path.join(pluginDir, 'package.json'),
    JSON.stringify(packageJson, null, 2)
  )
  
  await fs.writeFile(
    path.join(pluginDir, 'config/plugin.yaml'),
    pluginYaml
  )
  
  await fs.writeFile(
    path.join(pluginDir, 'src/index.js'),
    indexJs
  )
  
  await fs.writeFile(
    path.join(pluginDir, 'src/config.js'),
    configJs
  )
  
  await fs.writeFile(
    path.join(pluginDir, 'tests/commands.test.js'),
    tests.commandsTest
  )
  
  await fs.writeFile(
    path.join(pluginDir, 'tests/integration.test.js'),
    tests.integrationTest
  )
  
  // Create README
  const readme = \`# @kingly/\${pluginName}

\${PLUGIN_TYPES[pluginType]}

## Installation

\\\`\\\`\\\`bash
pnpm install
\\\`\\\`\\\`

## Usage

\\\`\\\`\\\`bash
# Start plugin
kingly \${pluginName} start

# Check status  
kingly \${pluginName} status
\\\`\\\`\\\`

## Features

\${features.length > 0 ? features.map(f => \`- \${FEATURES[f]}\`).join('\\n') : '- Basic plugin functionality'}

## Development

\\\`\\\`\\\`bash
# Run tests
pnpm test

# Development mode
pnpm dev
\\\`\\\`\\\`

## Configuration

Plugin configuration is defined in \\\`config/plugin.yaml\\\`.

Generated by @kingly/plugin generator.
\`
  
  await fs.writeFile(path.join(pluginDir, 'README.md'), readme)
  
  // Create .plugin-config.json for metadata
  const pluginConfig = {
    name: pluginName,
    type: pluginType,
    features,
    generated: new Date().toISOString(),
    generator: '@kingly/plugin'
  }
  
  await fs.writeFile(
    path.join(pluginDir, '.plugin-config.json'),
    JSON.stringify(pluginConfig, null, 2)
  )
  
  console.log('‚úÖ Plugin created successfully!')
  console.log(\`\\nüì¶ Next steps:
  1. cd packages/\${pluginName}
  2. pnpm install
  3. pnpm test
  4. Start developing your plugin!\`)
}

// Run if called directly
if (import.meta.url === \`file://\${process.argv[1]}\`) {
  createPlugin().catch(console.error)
}